// Generated by CoffeeScript 1.6.3
(function() {
  var BigBuffer, fs;

  fs = require("fs");

  BigBuffer = (function() {
    BigBuffer.fromFile = function(path, callback) {
      var e;
      try {
        return callback(null, this.fromFileSync(path));
      } catch (_error) {
        e = _error;
        return callback(e);
      }
    };

    BigBuffer.fromFileSync = function(path) {
      var KB, bb, buffer, fd, howManyRead, mayBeTotal, oldLength, total;
      KB = 1024;
      bb = new BigBuffer();
      fd = fs.openSync(path, "r");
      buffer = new Buffer(bb.blockSize);
      total = 0;
      mayBeTotal = 0;
      while (true) {
        howManyRead = fs.readSync(fd, buffer, 0, buffer.length, null);
        if (!howManyRead || howManyRead === 0) {
          break;
        }
        oldLength = bb.length;
        total += howManyRead;
        bb.write(buffer, 0, howManyRead);
        mayBeTotal += bb.length - oldLength;
      }
      fs.closeSync(fd);
      return bb;
    };

    function BigBuffer() {
      var _this = this;
      this.blocks = [];
      this.blockSize = 256 * 1024;
      this.count = 0;
      this.lastBlockLength = 0;
      this.__defineGetter__("length", function() {
        if (_this.blocks.length === 0) {
          return 0;
        }
        return (_this.blocks.length - 1) * _this.blockSize + _this.lastBlockLength;
      });
      this.__defineSetter__("length", function(value) {
        var block, index, _i, _len, _ref;
        if (value < 0) {
          throw new Error;
        }
        _this.blocks.length = Math.ceil(value / _this.blockSize);
        _ref = _this.blocks;
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          block = _ref[index];
          if (!block) {
            _this.blocks[index] = new Buffer(_this.blockSize);
          }
        }
        return _this.lastBlockLength = ((value - 1) % _this.blockSize) + 1;
      });
    }

    BigBuffer.prototype.free = function() {
      this.blocks.length = 0;
      return this.lastBlockLength = 0;
    };

    BigBuffer.prototype._writeBlock = function(blockIndex, offset, buffer) {
      var block;
      block = this.blocks[blockIndex];
      return buffer.copy(block, offset);
    };

    BigBuffer.prototype.blockIndexByByteOffset = function(index) {
      return Math.floor(index / this.blockSize);
    };

    BigBuffer.prototype.offsetWithinBlock = function(index) {
      return index % this.blockSize;
    };

    BigBuffer.prototype.write = function(buffer, offset, length) {
      var bufferStart, howMany, partToWrite, start, toBreak;
      if (!buffer) {
        throw new Error("Write request a Buffer as first parameter");
      }
      offset = offset || 0;
      length = length || buffer.length;
      if (offset + length > buffer.length) {
        throw new Error("Write buffer params out of index");
      }
      start = this.length;
      bufferStart = offset;
      this.length += length;
      while (true) {
        howMany = this.blockSize - this.offsetWithinBlock(start);
        if (howMany >= length - bufferStart) {
          howMany = length - bufferStart;
          toBreak = true;
        }
        partToWrite = buffer.slice(offset, offset + length);
        this._writeBlock(this.blockIndexByByteOffset(start), this.offsetWithinBlock(start), partToWrite);
        if (toBreak) {
          break;
        }
        bufferStart += howMany;
        start += howMany;
      }
      return this;
    };

    BigBuffer.prototype.slice = function(start, end) {
      var block, buffer, buffers, howMany, length;
      length = end - start;
      if (start > end) {
        throw new Error("start should less than end");
      }
      if (end > this.length) {
        throw new Error("Index out of range");
      }
      if (start < 0 || end <= 0) {
        throw new Error("Invalid Offset or Index");
      }
      buffers = [];
      while (start < end) {
        howMany = this.blockSize - this.offsetWithinBlock(start);
        if (howMany > end - start) {
          howMany = end - start;
        }
        block = this.blocks[this.blockIndexByByteOffset(start)];
        buffer = block.slice(this.offsetWithinBlock(start), this.offsetWithinBlock(start) + howMany);
        buffers.push(buffer);
        start += howMany;
      }
      return Buffer.concat(buffers, length);
    };

    BigBuffer.prototype.byteAt = function(index) {
      var block, blockIndex, tailIndex;
      if (index >= this.length) {
        throw new Error("Index Error");
      }
      blockIndex = Math.floor(index / this.blockSize);
      if (blockIndex >= this.blocks.length) {
        throw new Error("Range Error");
      }
      block = this.blocks[blockIndex];
      tailIndex = index % this.blockSize;
      return block[tailIndex];
    };

    BigBuffer.prototype.toBuffer = function() {
      return Buffer.concat(this.blocks, this.length);
    };

    return BigBuffer;

  })();

  module.exports = BigBuffer;

}).call(this);
